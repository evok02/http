package headers

import (
	"bytes"
	"strings"
	"errors"
)

type Headers map[string]string

const CRLF = "\r\n"

var ERROR_MALFORMED_HEADER = errors.New("malformed header block")
var ERROR_INVALID_HEADER_NAME = errors.New("invalid header name")

func NewHeaders() Headers {
	return make(Headers)
}

func (h Headers) Parse(data []byte) (n int, done bool, err error) {
	idx := bytes.Index(data, []byte(CRLF))
	switch idx {
	case -1:
		return 0, false, nil
	case 0:
		return 0, true, nil
	}

	key, value, err := parseFieldLine(data[:idx])
	if err != nil {
		return 0, false, err
	}

	h[key] = value
	return idx + len(CRLF), false, nil
}

func parseFieldLine(line []byte) (string, string, error) {
	idx := bytes.Index(line, []byte(":"))
	if idx == -1 {
		return "", "", ERROR_MALFORMED_HEADER
	}
	sepLineStr := []string{string(line[:idx]), string(line[idx + 1:])}
	
	key, value := strings.ToLower(sepLineStr[0]), strings.ToLower(sepLineStr[1])
	if err := validateFieldName(key); err != nil {
		return "", "", err
	}

	return strings.TrimSpace(key), strings.TrimSpace(value), nil
}

func validateFieldName(token string) error {
	if len(token) < 1 {
		return ERROR_MALFORMED_HEADER
	}

	if token[len(token) - 1] == ' ' {
		return ERROR_MALFORMED_HEADER
	}
	return nil
}

func validateTokenChars(token string) error {
	for _, char := range token {
		char == (34 || 40 || 41 || 44 || 47) || (char > 57 && char < 65)
	}
}

func (h Headers) Get(key string) (string, error) {
	val, ok := h[key]
	if !ok {
		return "", ERROR_INVALID_HEADER_NAME
	}
	return val, nil
}



